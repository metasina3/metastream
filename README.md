# Metastream (Aparat RTMP) — Full Scaffold

> Python (FastAPI + Jinja), Celery, Redis, Postgres, Docker Compose

این اسکفلد مینیمال همهٔ بخش‌های اصلی که گفتی رو می‌سازه: ادمین/یوزر، مدیریت کانال‌های RTMP، آپلود و آماده‌سازی ویدیو با ffmpeg، زمان‌بندی و جلوگیری از تداخل، پخش به آپارات با شبیه‌سازی لایو (-re)، صفحهٔ اختصاصی پخش با کامنت‌گذاری و تاخیر ۱۵ ثانیه‌ای و امکان مدیریت/Moderation، ثبت بیننده‌ها، سیاست نگهداری فایل‌ها، و محدودیت همزمانی آماده‌سازی (حداکثر ۲).

> **نکته**: این یک MVP است؛ کدها طوری نوشته شده که سریع بالا بیاد و قابل توسعه باشد. جزئیات امنیت/UX را می‌توان مرحله‌ای ارتقاء داد.

---

## 1) یک‌جا همه‌چیز را بساز: `bootstrap.sh`

**کپی کن داخل یک فایل به نام **``** و اجرا کن**

```bash
#!/usr/bin/env bash
set -euo pipefail

PROJECT_DIR="metastream"

mkdir -p "$PROJECT_DIR"
cd "$PROJECT_DIR"

mkdir -p app/{routers,tasks,templates/static,templates/pages,templates/partials,static/{css,js},media/{uploads,prepared,logos},core,utils}

# ------------------------------
# requirements.txt
# ------------------------------
cat > requirements.txt << 'EOF'
fastapi==0.115.0
uvicorn==0.30.6
Jinja2==3.1.4
python-multipart==0.0.9
pydantic==2.9.2
SQLAlchemy==2.0.36
alembic==1.13.3
psycopg2-binary==2.9.9
passlib[bcrypt]==1.7.4
itsdangerous==2.2.0
python-dotenv==1.0.1
celery[redis]==5.4.0
redis==5.0.8
python-jose[cryptography]==3.3.0
websockets==12.0
aiofiles==23.2.1
EOF

# ------------------------------
# Dockerfile
# ------------------------------
cat > Dockerfile << 'EOF'
FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    ffmpeg \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt ./
RUN pip install -r requirements.txt
COPY app ./app
COPY alembic.ini ./alembic.ini || true
COPY migrations ./migrations || true

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
EOF

# ------------------------------
# docker-compose.yml
# ------------------------------
cat > docker-compose.yml << 'EOF'
services:
  web:
    build: .
    container_name: ms_web
    env_file: .env
    volumes:
      - ./app:/app/app
      - ./app/media:/app/app/media
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis

  prep_worker:
    build: .
    container_name: ms_prep_worker
    env_file: .env
    command: ["celery", "-A", "app.core.celery_app.celery", "worker", "-Q", "prep", "--concurrency=2", "-Ofair"]
    volumes:
      - ./app:/app/app
      - ./app/media:/app/app/media
    depends_on:
      - web
      - redis

  stream_worker:
    build: .
    container_name: ms_stream_worker
    env_file: .env
    command: ["celery", "-A", "app.core.celery_app.celery", "worker", "-Q", "stream,default", "--concurrency=3", "-Ofair"]
    volumes:
      - ./app:/app/app
      - ./app/media:/app/app/media
    depends_on:
      - web
      - redis

  beat:
    build: .
    container_name: ms_beat
    env_file: .env
    command: ["celery", "-A", "app.core.celery_app.celery", "beat", "-l", "info"]
    volumes:
      - ./app:/app/app
    depends_on:
      - redis

  redis:
    image: redis:7-alpine
    container_name: ms_redis
    ports:
      - "6379:6379"

  db:
    image: postgres:15-alpine
    container_name: ms_db
    environment:
      POSTGRES_DB: metastream
      POSTGRES_USER: metastream
      POSTGRES_PASSWORD: metastream
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  flower:
    image: mher/flower:1.2.0
    container_name: ms_flower
    environment:
      - FLOWER_PORT=5555
    command: ["flower", "--url_prefix=/flower", "--port=5555", "--broker=redis://redis:6379/0"]
    ports:
      - "5555:5555"
    depends_on:
      - redis

volumes:
  pgdata:
EOF

# ------------------------------
# .env
# ------------------------------
cat > .env << 'EOF'
APP_NAME=Metastream
SECRET_KEY=change-this-secret
SQLALCHEMY_DATABASE_URI=postgresql+psycopg2://metastream:metastream@db:5432/metastream
REDIS_URL=redis://redis:6379/0
# Jalali/Tehran for users؛ سرور شما ممکنه Europe/Berlin باشه اما زمان‌بندی را UTC ذخیره می‌کنیم
TZ=UTC

# Admin bootstrap
ADMIN_EMAIL=admin@metastream.ir
ADMIN_PASSWORD=ChangeMe123!

# File retention (days)
RETENTION_DAYS=30

# FFmpeg thread reserve (keep 2 cores free):
CPU_RESERVE=2
EOF

# ------------------------------
# Alembic minimal (optional; fallback create_all نیز داریم)
# ------------------------------
cat > alembic.ini << 'EOF'
[alembic]
script_location = migrations
sqlalchemy.url = postgresql+psycopg2://metastream:metastream@db:5432/metastream
EOF

mkdir -p migrations/versions
cat > migrations/README << 'EOF'
Autogenerated by scaffold (optionally use alembic later).
EOF

# ------------------------------
# app/core/config.py
# ------------------------------
cat > app/core/config.py << 'EOF'
from pydantic import BaseModel
import os

class Settings(BaseModel):
    APP_NAME: str = os.getenv("APP_NAME", "Metastream")
    SECRET_KEY: str = os.getenv("SECRET_KEY", "change-me")
    SQLALCHEMY_DATABASE_URI: str = os.getenv("SQLALCHEMY_DATABASE_URI")
    REDIS_URL: str = os.getenv("REDIS_URL", "redis://redis:6379/0")
    ADMIN_EMAIL: str = os.getenv("ADMIN_EMAIL", "admin@metastream.ir")
    ADMIN_PASSWORD: str = os.getenv("ADMIN_PASSWORD", "admin")
    RETENTION_DAYS: int = int(os.getenv("RETENTION_DAYS", "30"))
    CPU_RESERVE: int = int(os.getenv("CPU_RESERVE", "2"))

settings = Settings()
EOF

# ------------------------------
# app/core/database.py
# ------------------------------
cat > app/core/database.py << 'EOF'
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, DeclarativeBase
from app.core.config import settings

engine = create_engine(settings.SQLALCHEMY_DATABASE_URI, pool_pre_ping=True, future=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine, future=True)

class Base(DeclarativeBase):
    pass
EOF

# ------------------------------
# app/core/security.py
# ------------------------------
cat > app/core/security.py << 'EOF'
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(p: str) -> str:
    return pwd_context.hash(p)

def verify_password(p: str, h: str) -> bool:
    return pwd_context.verify(p, h)
EOF

# ------------------------------
# app/core/celery_app.py
# ------------------------------
cat > app/core/celery_app.py << 'EOF'
from celery import Celery
from app.core.config import settings

celery = Celery(
    "metastream",
    broker=settings.REDIS_URL,
    backend=settings.REDIS_URL,
    include=[
        "app.tasks.video",
        "app.tasks.stream",
    ],
)

celery.conf.update(
    task_acks_late=True,
    worker_max_tasks_per_child=50,
    timezone="UTC",
    task_routes={
        "app.tasks.video.prepare_video": {"queue": "prep"},
        "app.tasks.stream.start_stream": {"queue": "stream"},
        "app.tasks.stream.cancel_stream": {"queue": "stream"},
        "app.tasks.stream.dispatch_upcoming_streams": {"queue": "default"},
    },
    beat_schedule={
        "dispatch-upcoming": {
            "task": "app.tasks.stream.dispatch_upcoming_streams",
            "schedule": 10.0,
        },
        "cleanup-old-files": {
            "task": "app.tasks.video.cleanup_old_files",
            "schedule": 3600.0,
        },
    },
)
EOF

# ------------------------------
# app/models.py
# ------------------------------
cat > app/models.py << 'EOF'
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy import String, Integer, Boolean, DateTime, ForeignKey, Text, Float
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.core.database import Base

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    name: Mapped[str] = mapped_column(String(255))
    password_hash: Mapped[str] = mapped_column(String(255))
    is_admin: Mapped[bool] = mapped_column(Boolean, default=False)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    channels: Mapped[list["Channel"]] = relationship(back_populates="owner")

class Channel(Base):
    __tablename__ = "channels"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    name: Mapped[str] = mapped_column(String(200))
    aparat_username: Mapped[str] = mapped_column(String(200))
    rtmp_url: Mapped[str] = mapped_column(Text)
    stream_key: Mapped[str] = mapped_column(Text)
    embed_code: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    owner: Mapped[User] = relationship(back_populates="channels")

class Video(Base):
    __tablename__ = "videos"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    title: Mapped[str] = mapped_column(String(255))
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    src_path: Mapped[str] = mapped_column(Text)
    prepared_path: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    duration_sec: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    status: Mapped[str] = mapped_column(String(50), default="uploaded")  # uploaded|preparing|ready|failed
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

class StreamSchedule(Base):
    __tablename__ = "streams"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    channel_id: Mapped[int] = mapped_column(ForeignKey("channels.id"))
    video_id: Mapped[int] = mapped_column(ForeignKey("videos.id"))
    title: Mapped[str] = mapped_column(String(255))
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    logo_path: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    allow_comments: Mapped[bool] = mapped_column(Boolean, default=True)
    start_time: Mapped[datetime] = mapped_column(DateTime, index=True)
    end_time: Mapped[datetime] = mapped_column(DateTime, index=True)
    status: Mapped[str] = mapped_column(String(50), default="scheduled")  # scheduled|starting|live|finished|canceled|failed
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

class StreamProcess(Base):
    __tablename__ = "stream_processes"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    stream_id: Mapped[int] = mapped_column(ForeignKey("streams.id"), unique=True)
    pid: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    cancel_flag: Mapped[bool] = mapped_column(Boolean, default=False)
    started_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
    finished_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

class Comment(Base):
    __tablename__ = "comments"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    stream_id: Mapped[int] = mapped_column(ForeignKey("streams.id"), index=True)
    user_display: Mapped[str] = mapped_column(String(255))
    text: Mapped[str] = mapped_column(Text)
    approved: Mapped[bool] = mapped_column(Boolean, default=False)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, index=True)

class Viewer(Base):
    __tablename__ = "viewers"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    stream_id: Mapped[int] = mapped_column(ForeignKey("streams.id"), index=True)
    name: Mapped[str] = mapped_column(String(255))
    phone: Mapped[str] = mapped_column(String(50))
    joined_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

class Setting(Base):
    __tablename__ = "settings"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    key: Mapped[str] = mapped_column(String(100), unique=True)
    value: Mapped[str] = mapped_column(Text)
EOF

# ------------------------------
# app/utils/ffmpeg.py
# ------------------------------
cat > app/utils/ffmpeg.py << 'EOF'
import subprocess, json, os, shlex, multiprocessing
from app.core.config import settings

FFPROBE = "ffprobe"
FFMPEG = "ffmpeg"

ALLOWED_VCODECS = {"h264"}
ALLOWED_ACODECS = {"aac", "mp4a"}


def run(cmd: str) -> int:
    print("[ff]", cmd)
    return subprocess.call(cmd, shell=True)


def probe_duration(input_path: str) -> float:
    cmd = f"{FFPROBE} -v quiet -print_format json -show_format -show_streams {shlex.quote(input_path)}"
    out = subprocess.check_output(cmd, shell=True).decode()
    data = json.loads(out)
    if "format" in data and "duration" in data["format"]:
        return float(data["format"]["duration"])
    return 0.0


def check_codecs(input_path: str) -> tuple[bool, bool]:
    """Returns (v_ok, a_ok) whether video/audio codecs already compatible."""
    cmd = f"{FFPROBE} -v quiet -print_format json -show_streams {shlex.quote(input_path)}"
    data = json.loads(subprocess.check_output(cmd, shell=True).decode())
    v_ok = a_ok = False
    for s in data.get("streams", []):
        if s.get("codec_type") == "video":
            v_ok = s.get("codec_name") in ALLOWED_VCODECS and s.get("pix_fmt") == "yuv420p"
        if s.get("codec_type") == "audio":
            a_ok = s.get("codec_name") in ALLOWED_ACODECS
    return v_ok, a_ok


def threads_for_encode() -> int:
    total = multiprocessing.cpu_count()
    reserve = max(0, settings.CPU_RESERVE)
    return max(1, total - reserve)


def prepare(input_path: str, output_path: str) -> tuple[int, str]:
    v_ok, a_ok = check_codecs(input_path)
    # If both ok, just faststart remux to mp4
    th = threads_for_encode()
    if v_ok and a_ok:
        cmd = (
            f"{FFMPEG} -y -i {shlex.quote(input_path)} -c:v copy -c:a copy -movflags +faststart "
            f"{shlex.quote(output_path)}"
        )
        return run(cmd), "copy"
    # Otherwise, single-time transcode (offline) to h264+aac
    cmd = (
        f"{FFMPEG} -y -i {shlex.quote(input_path)} -c:v libx264 -preset veryfast -profile:v high -pix_fmt yuv420p "
        f"-c:a aac -b:a 128k -movflags +faststart -threads {th} {shlex.quote(output_path)}"
    )
    return run(cmd), "transcode"


def stream_to_rtmp(prepared_path: str, rtmp_url: str, stream_key: str) -> subprocess.Popen:
    # -re for realtime; prefer copy to avoid re-encode; ensure AAC audio
    cmd = [
        FFMPEG, "-re", "-i", prepared_path,
        "-c:v", "copy", "-c:a", "aac", "-b:a", "128k", "-f", "flv", f"{rtmp_url}/{stream_key}"
    ]
    print("[ff] start:", " ".join(cmd))
    proc = subprocess.Popen(cmd)
    return proc
EOF

# ------------------------------
# app/tasks/video.py
# ------------------------------
cat > app/tasks/video.py << 'EOF'
from datetime import datetime, timedelta
import os
from celery import shared_task
from sqlalchemy import select, delete
from app.core.celery_app import celery
from app.core.database import SessionLocal
from app.models import Video
from app.utils.ffmpeg import prepare, probe_duration
from app.core.config import settings

@shared_task(name="app.tasks.video.prepare_video")
def prepare_video(video_id: int):
    with SessionLocal() as db:
        v = db.get(Video, video_id)
        if not v:
            return "not-found"
        v.status = "preparing"
        db.commit()
        src = v.src_path
        base = os.path.basename(src)
        out = os.path.join("app", "media", "prepared", f"prep_{v.id}.mp4")
        code, mode = prepare(src, out)
        if code == 0:
            v.prepared_path = out
            v.duration_sec = probe_duration(out) or v.duration_sec
            v.status = "ready"
        else:
            v.status = "failed"
        db.commit()
        return v.status

@shared_task(name="app.tasks.video.cleanup_old_files")
def cleanup_old_files():
    # Delete prepared and upload files older than RETENTION_DAYS if not used in future streams.
    from app.models import StreamSchedule
    keep_until = datetime.utcnow() - timedelta(days=settings.RETENTION_DAYS)
    removed = []
    with SessionLocal() as db:
        vids = db.execute(select(Video).where(Video.created_at < keep_until)).scalars().all()
        for v in vids:
            # Only if no future streams depend on it
            future = db.execute(select(StreamSchedule).where(StreamSchedule.video_id==v.id, StreamSchedule.start_time>datetime.utcnow())).scalar()
            if future:
                continue
            for p in [v.prepared_path, v.src_path]:
                if p and os.path.exists(p):
                    try:
                        os.remove(p)
                        removed.append(p)
                    except Exception:
                        pass
            db.delete(v)
        db.commit()
    return {"removed": removed}
EOF

# ------------------------------
# app/tasks/stream.py
# ------------------------------
cat > app/tasks/stream.py << 'EOF'
from datetime import datetime, timedelta
import os, signal, time
from celery import shared_task
from sqlalchemy import select
from app.core.celery_app import celery
from app.core.database import SessionLocal
from app.models import StreamSchedule, StreamProcess, Channel, Video
from app.utils.ffmpeg import stream_to_rtmp

@shared_task(name="app.tasks.stream.dispatch_upcoming_streams")
def dispatch_upcoming_streams():
    now = datetime.utcnow()
    with SessionLocal() as db:
        q = db.execute(select(StreamSchedule).where(
            StreamSchedule.status=="scheduled",
            StreamSchedule.start_time <= now + timedelta(seconds=5)
        )).scalars().all()
        for s in q:
            start_stream.delay(s.id)
    return {"dispatched": len(q)}

@shared_task(bind=True, name="app.tasks.stream.start_stream")
def start_stream(self, stream_id: int):
    with SessionLocal() as db:
        s = db.get(StreamSchedule, stream_id)
        if not s:
            return "not-found"
        ch = db.get(Channel, s.channel_id)
        v = db.get(Video, s.video_id)
        if not (ch and v and v.prepared_path and os.path.exists(v.prepared_path)):
            s.status = "failed"; db.commit(); return "bad-input"
        # Mark starting
        s.status = "starting"; db.commit()
        # Register process row
        sp = db.execute(select(StreamProcess).where(StreamProcess.stream_id==s.id)).scalar_one_or_none()
        if not sp:
            sp = StreamProcess(stream_id=s.id)
            db.add(sp); db.commit(); db.refresh(sp)
        # Start ffmpeg
        proc = stream_to_rtmp(v.prepared_path, ch.rtmp_url, ch.stream_key)
        sp.pid = proc.pid; sp.started_at = datetime.utcnow(); db.commit()
        s.status = "live"; db.commit()
        # Monitor loop with cancel flag
        while True:
            time.sleep(2)
            db.expire(sp)
            sp = db.get(StreamProcess, sp.id)
            if sp.cancel_flag:
                try:
                    os.kill(proc.pid, signal.SIGINT)
                except Exception:
                    pass
                break
            ret = proc.poll()
            if ret is not None:
                break
        # Finalize
        s.status = "finished" if proc.poll() == 0 and not sp.cancel_flag else ("canceled" if sp.cancel_flag else "failed")
        sp.finished_at = datetime.utcnow()
        db.commit()
        return s.status

@shared_task(name="app.tasks.stream.cancel_stream")
def cancel_stream(stream_id: int):
    with SessionLocal() as db:
        sp = db.execute(select(StreamProcess).where(StreamProcess.stream_id==stream_id)).scalar_one_or_none()
        if not sp:
            return "no-proc"
        sp.cancel_flag = True
        db.commit()
        # The running task loop will terminate ffmpeg gracefully
        return "ok"
EOF

# ------------------------------
# app/routers/__init__.py
# ------------------------------
cat > app/routers/__init__.py << 'EOF'
# empty
EOF

# ------------------------------
# app/routers/auth.py
# ------------------------------
cat > app/routers/auth.py << 'EOF'
from fastapi import APIRouter, Request, Form, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy import select
from app.core.database import SessionLocal
from app.core.security import verify_password, hash_password
from app.models import User

router = APIRouter()

@router.get("/login")
async def login_form(request: Request):
    return request.app.state.templates.TemplateResponse("pages/login.html", {"request": request})

@router.post("/login")
async def login(request: Request, email: str = Form(...), password: str = Form(...)):
    with SessionLocal() as db:
        u = db.execute(select(User).where(User.email==email)).scalar_one_or_none()
        if not u or not verify_password(password, u.password_hash):
            return request.app.state.templates.TemplateResponse("pages/login.html", {"request": request, "error": "نام کاربری یا رمز نادرست"})
        request.session["uid"] = u.id
        return RedirectResponse(url="/dashboard", status_code=303)

@router.get("/logout")
async def logout(request: Request):
    request.session.clear()
    return RedirectResponse("/login", status_code=303)
EOF

# ------------------------------
# app/routers/dashboard.py
# ------------------------------
cat > app/routers/dashboard.py << 'EOF'
from fastapi import APIRouter, Request, UploadFile, File, Form, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy import select, and_
import os, shutil
from app.core.database import SessionLocal
from app.models import User, Video, Channel, StreamSchedule, Setting
from app.tasks.video import prepare_video

router = APIRouter()


def current_user(request: Request):
    uid = request.session.get("uid")
    if not uid:
        return None
    with SessionLocal() as db:
        return db.get(User, uid)

@router.get("/dashboard")
async def dash(request: Request):
    u = current_user(request)
    if not u:
        return RedirectResponse("/login", status_code=303)
    with SessionLocal() as db:
        vids = db.execute(select(Video).where(Video.user_id==u.id).order_by(Video.id.desc())).scalars().all()
        chs = db.execute(select(Channel).where(Channel.user_id==u.id)).scalars().all()
        streams = db.execute(select(StreamSchedule).where(StreamSchedule.user_id==u.id).order_by(StreamSchedule.id.desc())).scalars().all()
    return request.app.state.templates.TemplateResponse("pages/dashboard.html", {"request": request, "user": u, "videos": vids, "channels": chs, "streams": streams})

@router.post("/videos/upload")
async def upload_video(request: Request, file: UploadFile = File(...), title: str = Form("ویدیو بدون عنوان"), description: str = Form("")):
    u = current_user(request)
    if not u:
        return RedirectResponse("/login", status_code=303)
    dst_dir = "app/media/uploads"
    os.makedirs(dst_dir, exist_ok=True)
    dst = os.path.join(dst_dir, file.filename)
    with open(dst, "wb") as f:
        shutil.copyfileobj(file.file, f)
    with SessionLocal() as db:
        v = Video(user_id=u.id, title=title, description=description, src_path=dst)
        db.add(v); db.commit(); db.refresh(v)
        prepare_video.delay(v.id)
    return RedirectResponse("/dashboard", status_code=303)

@router.post("/channels/create")
async def create_channel(request: Request,
    name: str = Form(...), aparat_username: str = Form(...), rtmp_url: str = Form(...), stream_key: str = Form(...), embed_code: str = Form("")
):
    u = current_user(request)
    if not u:
        return RedirectResponse("/login", status_code=303)
    with SessionLocal() as db:
        ch = Channel(user_id=u.id, name=name, aparat_username=aparat_username, rtmp_url=rtmp_url, stream_key=stream_key, embed_code=embed_code or None)
        db.add(ch); db.commit()
    return RedirectResponse("/dashboard", status_code=303)

@router.post("/streams/schedule")
async def schedule_stream(request: Request,
    video_id: int = Form(...), channel_id: int = Form(...), title: str = Form(...), description: str = Form(""),
    start_time_iso: str = Form(...), logo: UploadFile | None = File(None), allow_comments: bool = Form(False)
):
    from datetime import datetime, timedelta
    u = current_user(request)
    if not u:
        return RedirectResponse("/login", status_code=303)
    logo_path = None
    if logo and logo.filename:
        dst_dir = "app/media/logos"; os.makedirs(dst_dir, exist_ok=True)
        logo_path = os.path.join(dst_dir, f"{u.id}_{logo.filename}")
        with open(logo_path, "wb") as f:
            shutil.copyfileobj(logo.file, f)
    with SessionLocal() as db:
        v = db.get(Video, video_id)
        if not (v and v.status=="ready"):
            return RedirectResponse("/dashboard?err=video_not_ready", status_code=303)
        # compute end time (+120s buffer)
        st = datetime.fromisoformat(start_time_iso)
        et = st + timedelta(seconds=(v.duration_sec or 0) + 120)
        # overlap guard for same channel
        q = select(StreamSchedule).where(StreamSchedule.channel_id==channel_id, StreamSchedule.end_time>st, StreamSchedule.start_time<et)
        conflict = db.execute(q).scalar_one_or_none()
        if conflict:
            return RedirectResponse("/dashboard?err=overlap", status_code=303)
        s = StreamSchedule(user_id=u.id, channel_id=channel_id, video_id=video_id, title=title, description=description, logo_path=logo_path, allow_comments=allow_comments, start_time=st, end_time=et)
        db.add(s); db.commit()
    return RedirectResponse("/dashboard", status_code=303)
EOF

# ------------------------------
# app/routers/player.py
# ------------------------------
cat > app/routers/player.py << 'EOF'
from fastapi import APIRouter, Request, Form
from fastapi.responses import RedirectResponse
from sqlalchemy import select
from app.core.database import SessionLocal
from app.models import StreamSchedule, Comment, Viewer, Channel
from datetime import datetime, timedelta

router = APIRouter()

@router.get("/p/{stream_id}")
async def player_page(stream_id: int, request: Request):
    with SessionLocal() as db:
        s = db.get(StreamSchedule, stream_id)
        if not s:
            return RedirectResponse("/notfound", status_code=303)
        ch = db.get(Channel, s.channel_id)
    return request.app.state.templates.TemplateResponse("pages/player.html", {"request": request, "stream": s, "channel": ch})

@router.post("/p/{stream_id}/enter")
async def enter_view(stream_id: int, request: Request, name: str = Form(...), phone: str = Form(...)):
    with SessionLocal() as db:
        v = Viewer(stream_id=stream_id, name=name, phone=phone)
        db.add(v); db.commit(); db.refresh(v)
    request.session[f"viewer_{stream_id}"] = v.id
    return RedirectResponse(f"/p/{stream_id}", status_code=303)

@router.post("/p/{stream_id}/comment")
async def add_comment(stream_id: int, request: Request, user_display: str = Form(...), text: str = Form(...)):
    # Require viewer session
    if request.session.get(f"viewer_{stream_id}") is None and request.session.get("uid") is None:
        return RedirectResponse(f"/p/{stream_id}?err=not_entered", status_code=303)
    with SessionLocal() as db:
        c = Comment(stream_id=stream_id, user_display=user_display, text=text, approved=False)
        db.add(c); db.commit()
    return RedirectResponse(f"/p/{stream_id}", status_code=303)

@router.get("/p/{stream_id}/comments")
async def list_comments(stream_id: int, request: Request):
    # Public feed: only approved and 15s delay
    delay = timedelta(seconds=15)
    cutoff = datetime.utcnow() - delay
    with SessionLocal() as db:
        rows = db.execute(select(Comment).where(Comment.stream_id==stream_id, Comment.approved==True, Comment.created_at <= cutoff).order_by(Comment.id.asc())).scalars().all()
    return [{"id": r.id, "user": r.user_display, "text": r.text, "ts": r.created_at.isoformat()} for r in rows]
EOF

# ------------------------------
# app/routers/moderation.py
# ------------------------------
cat > app/routers/moderation.py << 'EOF'
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from sqlalchemy import select
from app.core.database import SessionLocal
from app.models import Comment, StreamSchedule

router = APIRouter()


def require_owner(request: Request, stream_id: int) -> bool:
    uid = request.session.get("uid")
    if not uid:
        return False
    with SessionLocal() as db:
        s = db.get(StreamSchedule, stream_id)
        return s and s.user_id == uid or False

@router.get("/moderation/{stream_id}/comments")
async def mod_list(stream_id: int, request: Request):
    if not require_owner(request, stream_id):
        return JSONResponse(status_code=403, content={"error": "forbidden"})
    with SessionLocal() as db:
        rows = db.execute(select(Comment).where(Comment.stream_id==stream_id).order_by(Comment.id.desc())).scalars().all()
    return [{"id": r.id, "user": r.user_display, "text": r.text, "approved": r.approved} for r in rows]

@router.post("/moderation/{stream_id}/comments/{cid}/approve")
async def approve(stream_id: int, cid: int, request: Request):
    if not require_owner(request, stream_id):
        return JSONResponse(status_code=403, content={"error": "forbidden"})
    with SessionLocal() as db:
        c = db.get(Comment, cid)
        if c:
            c.approved = True; db.commit()
    return {"ok": True}

@router.post("/moderation/{stream_id}/comments/{cid}/delete")
async def delete(stream_id: int, cid: int, request: Request):
    if not require_owner(request, stream_id):
        return JSONResponse(status_code=403, content={"error": "forbidden"})
    with SessionLocal() as db:
        c = db.get(Comment, cid)
        if c:
            db.delete(c); db.commit()
    return {"ok": True}
EOF

# ------------------------------
# app/main.py
# ------------------------------
cat > app/main.py << 'EOF'
from fastapi import FastAPI, Request
from fastapi.staticfiles import StaticFiles
from starlette.middleware.sessions import SessionMiddleware
from starlette.templating import Jinja2Templates
from app.core.database import Base, engine, SessionLocal
from app.core.config import settings
from app.core.security import hash_password
from app.models import User, Setting

from app.routers import auth, dashboard, player, moderation

app = FastAPI(title=settings.APP_NAME)
app.add_middleware(SessionMiddleware, secret_key=settings.SECRET_KEY, max_age=60*60*24*7)

app.mount("/static", StaticFiles(directory="app/static"), name="static")
app.mount("/media", StaticFiles(directory="app/media"), name="media")

app.state.templates = Jinja2Templates(directory="app/templates")

# Routers
app.include_router(auth.router)
app.include_router(dashboard.router)
app.include_router(player.router)
app.include_router(moderation.router)

@app.on_event("startup")
def on_startup():
    Base.metadata.create_all(bind=engine)
    # bootstrap admin
    with SessionLocal() as db:
        admin = db.query(User).filter(User.email==settings.ADMIN_EMAIL).first()
        if not admin:
            admin = User(email=settings.ADMIN_EMAIL, name="Admin", password_hash=hash_password(settings.ADMIN_PASSWORD), is_admin=True)
            db.add(admin); db.commit()
        # Default retention setting mirror .env
        s = db.query(Setting).filter(Setting.key=="retention_days").first()
        if not s:
            s = Setting(key="retention_days", value=str(settings.RETENTION_DAYS))
            db.add(s); db.commit()

@app.get("/")
async def index(request: Request):
    return app.state.templates.TemplateResponse("pages/index.html", {"request": request})
EOF

# ------------------------------
# TEMPLATES
# ------------------------------
cat > app/templates/base.html << 'EOF'
<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{ title or 'Metastream' }}</title>
  <link rel="stylesheet" href="/static/css/main.css" />
  <script src="https://cdn.jsdelivr.net/npm/persian-date@1.1.0/dist/persian-date.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/persian-datepicker@1.2.0/dist/js/persian-datepicker.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/persian-datepicker@1.2.0/dist/css/persian-datepicker.css" />
  <style>body{font-family:sans-serif;background:#0f172a;color:#e2e8f0} a{color:#93c5fd} .card{background:#111827;padding:16px;border-radius:12px;margin:8px 0}</style>
</head>
<body>
  <header style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;background:#111827;">
    <div>{{ request.app.title or 'Metastream' }}</div>
    <nav>
      <a href="/dashboard">داشبورد</a> | <a href="/logout">خروج</a>
    </nav>
  </header>
  <main style="max-width:1100px;margin:0 auto;padding:16px;">
    {% block content %}{% endblock %}
  </main>
</body>
</html>
EOF

cat > app/templates/pages/index.html << 'EOF'
{% extends 'base.html' %}
{% block content %}
<div class="card">
  <h2>Metastream</h2>
  <p>برای مدیریت وارد <a href="/login">پنل</a> شوید.</p>
</div>
{% endblock %}
EOF

cat > app/templates/pages/login.html << 'EOF'
{% extends 'base.html' %}
{% block content %}
<div class="card">
  <h2>ورود</h2>
  {% if error %}<div style="color:#fca5a5">{{ error }}</div>{% endif %}
  <form method="post" action="/login">
    <label>ایمیل</label><br>
    <input name="email" type="email" required><br>
    <label>رمز عبور</label><br>
    <input name="password" type="password" required><br><br>
    <button>ورود</button>
  </form>
</div>
{% endblock %}
EOF

cat > app/templates/pages/dashboard.html << 'EOF'
{% extends 'base.html' %}
{% block content %}
<h2>داشبورد</h2>
<div class="card">
  <h3>آپلود ویدیو</h3>
  <form method="post" action="/videos/upload" enctype="multipart/form-data">
    <input type="text" name="title" placeholder="عنوان">
    <input type="text" name="description" placeholder="توضیحات">
    <input type="file" name="file" required>
    <button>آپلود</button>
  </form>
</div>
<div class="card">
  <h3>افزودن کانال RTMP (Aparat)</h3>
  <form method="post" action="/channels/create">
    <input name="name" placeholder="نام کانال" required>
    <input name="aparat_username" placeholder="یوزرنیم آپارات" required>
    <input name="rtmp_url" placeholder="rtmp://..." required>
    <input name="stream_key" placeholder="Stream Key" required>
    <textarea name="embed_code" placeholder="کد Embed آپارات (اختیاری)"></textarea>
    <button>ذخیره</button>
  </form>
</div>
<div class="card">
  <h3>ویدیوها</h3>
  <table border="1" cellpadding="6"><tr><th>عنوان</th><th>وضعیت</th><th>مدت</th></tr>
  {% for v in videos %}
    <tr>
      <td>{{ v.title }}</td>
      <td>{{ v.status }}</td>
      <td>{{ '%.0f' % v.duration_sec if v.duration_sec else '-' }}</td>
    </tr>
  {% endfor %}
  </table>
</div>
<div class="card">
  <h3>زمان‌بندی استریم</h3>
  <form method="post" action="/streams/schedule" enctype="multipart/form-data">
    <select name="video_id" required>
      <option value="">انتخاب ویدیو (باید Ready باشد)</option>
      {% for v in videos if v.status=='ready' %}
      <option value="{{ v.id }}">{{ v.title }}</option>
      {% endfor %}
    </select>
    <select name="channel_id" required>
      <option value="">انتخاب کانال</option>
      {% for c in channels %}
      <option value="{{ c.id }}">{{ c.name }}</option>
      {% endfor %}
    </select>
    <input name="title" placeholder="عنوان استریم" required>
    <input name="description" placeholder="توضیحات">
    <input id="start_time_iso" name="start_time_iso" placeholder="زمان شروع (ISO)" required>
    <input type="file" name="logo">
    <label><input type="checkbox" name="allow_comments">فعال بودن کامنت</label>
    <button>رزرو</button>
  </form>
  <small>نکته: در صفحه با تاریخ شمسی، پیکر انتخاب زمان اضافه می‌کنیم که مقدار ISO را پر کند.</small>
</div>
<div class="card">
  <h3>رزروها</h3>
  <table border="1" cellpadding="6"><tr><th>عنوان</th><th>کانال</th><th>از</th><th>تا</th><th>وضعیت</th><th>لینک پخش</th></tr>
  {% for s in streams %}
    <tr>
      <td>{{ s.title }}</td>
      <td>{{ s.channel_id }}</td>
      <td>{{ s.start_time }}</td>
      <td>{{ s.end_time }}</td>
      <td>{{ s.status }}</td>
      <td><a href="/p/{{ s.id }}" target="_blank">صفحه پخش</a></td>
    </tr>
  {% endfor %}
  </table>
</div>
<script>
  // مثال ساده پر کردن ISO از پیکر شمسی
  // می‌توانید با persian-datepicker مقدار را بگیرید و به ISO تبدیل کنید
</script>
{% endblock %}
EOF

cat > app/templates/pages/player.html << 'EOF'
{% extends 'base.html' %}
{% block content %}
<h2>{{ stream.title }}</h2>
{% if request.session.get('viewer_' ~ stream.id) is none and request.session.get('uid') is none %}
<div class="card">
  <form method="post" action="/p/{{ stream.id }}/enter">
    <input name="name" placeholder="نام" required>
    <input name="phone" placeholder="شماره" required>
    <button>ورود به صفحه پخش</button>
  </form>
</div>
{% endif %}

{% if channel and channel.embed_code %}
<div class="card">
  <!-- Embed Aparat provided by channel -->
  {{ channel.embed_code | safe }}
</div>
{% else %}
<div class="card">کد Embed آپارات تنظیم نشده است.</div>
{% endif %}

{% if stream.logo_path %}
  <img src="/{{ stream.logo_path }}" alt="logo" style="max-height:64px;"/>
{% endif %}
<p>{{ stream.description }}</p>

{% if stream.allow_comments %}
<div class="card">
  <form method="post" action="/p/{{ stream.id }}/comment">
    <input name="user_display" placeholder="نام شما" required>
    <input name="text" placeholder="پیام" required>
    <button>ارسال کامنت</button>
  </form>
  <div id="comments"></div>
</div>
<script>
  async function loadComments(){
    const r = await fetch('/p/{{ stream.id }}/comments');
    const data = await r.json();
    const box = document.getElementById('comments');
    box.innerHTML = data.map(c => `<div class=card><b>${c.user}</b>: ${c.text}</div>`).join('');
  }
  setInterval(loadComments, 5000);
  loadComments();
</script>
{% endif %}

{% if request.session.get('uid') %}
<div class="card">
  <h3>مدیریت کامنت‌ها (لحظه‌ای)</h3>
  <div id="mod"></div>
</div>
<script>
  async function loadMod(){
    const r = await fetch('/moderation/{{ stream.id }}/comments');
    const data = await r.json();
    const box = document.getElementById('mod');
    box.innerHTML = data.map(c => `<div class=card>${c.user}: ${c.text} — ${c.approved? '✔' : '⏳'} `+
      `<button onclick=approve(${c.id})>قبول</button> <button onclick=delc(${c.id})>حذف</button></div>`).join('');
  }
  async function approve(id){ await fetch('/moderation/{{ stream.id }}/comments/'+id+'/approve',{method:'POST'}); loadMod(); }
  async function delc(id){ await fetch('/moderation/{{ stream.id }}/comments/'+id+'/delete',{method:'POST'}); loadMod(); }
  setInterval(loadMod, 3000); loadMod();
</script>
{% endif %}
{% endblock %}
EOF

# ------------------------------
# static placeholder
# ------------------------------
cat > app/static/css/main.css << 'EOF'
/* minimal styles */
EOF

# ------------------------------
# README quick tips
# ------------------------------
cat > README.md << 'EOF'
# Metastream (Aparat RTMP) — Scaffold

## Run
```

docker compose up -d --build

```
Open http://localhost:8000

Admin user from .env.

## Reverse Proxy Manager
- panel.metastream.ir → http://SERVER_IP:8000
- live.metastream.ir  → http://SERVER_IP:8000 (only viewer pages `/p/:id`)

## Notes
- Uploads: app/media/uploads
- Prepared: app/media/prepared
- Logos: app/media/logos
- Concurrency: prep queue capped to 2 (see docker-compose)
- Scheduling: Celery Beat dispatches near start time
- Cancellation: POST task sets cancel_flag; worker loop SIGINTs ffmpeg
- Comments: 15s delay for public; immediate for owner via moderation endpoints
- Retention: env RETENTION_DAYS + periodic cleanup task

EOF

echo "Scaffold generated in $(pwd)"
```

---

## 2) کارهای بعد از اجرا

1. روی سرور اوبونتو 22:
   ```bash
   bash bootstrap.sh
   docker compose up -d --build
   ```
2. در Reverse Proxy Manager:
   - `panel.metastream.ir` → بک‌اند: `http://127.0.0.1:8000` (یا IP سرور)
   - `live.metastream.ir`  → همان بک‌اند؛ لینک‌های پخش به شکل `/p/<id>`
3. لاگین با ایمیل/رمز داخل `.env` (بعداً از داخل دیتابیس یا فرم، کاربر بسازیم)
4. از داشبورد: کانال RTMP آپارات را اضافه کن (URL + Stream Key + کد Embed).
5. ویدیو اپلود → صبر تا وضعیت `ready` شود → زمان‌بندی کن.

---

## 3) نکات مهم پیاده‌سازی (داخل کد هم رعایت شده)

- **عدم دوباره‌انکود هنگام استریم**: در مرحلهٔ آماده‌سازی اگر ویدیو `h264+yuv420p` و صوت `aac` باشد، فقط remux می‌شود. لذا هنگام استریم: `-c:v copy -c:a aac -re`.
- **محدودیت CPU**: تعداد `-threads` براساس `cpu_count - CPU_RESERVE` محاسبه می‌شود.
- **دو پردازش آماده‌سازی همزمان**: worker صف `prep` با `--concurrency=2` بالا می‌آید.
- **لغو استریم/اتمام**: PID ذخیره می‌شود و حلقهٔ مانیتور روی `cancel_flag` نظارت می‌کند؛ SIGINT فقط همان ffmpeg را می‌بندد.
- **تداخل رزرو**: روی همان کانال، بازهٔ زمانی با حاشیهٔ ۱۲۰ ثانیه بررسی می‌شود.
- **تاخیر ۱۵ ثانیه‌ای کامنت**: API `/p/{id}/comments` فقط approved و دیرتر از ۱۵ ثانیه را برمی‌گرداند.
- **ثبت بیننده**: قبل از نمایش پخش، فرم نام/شماره؛ در session ذخیره و در DB ثبت می‌کنیم.
- **Jalali**: CDN persian-datepicker اضافه شده؛ می‌توان JS تبدیل به ISO را در فرم تکمیل کرد.

---

## 4) TODOهای سریع برای ارتقاء

- افزودن صفحهٔ ادمین برای دیدن آمار همهٔ یوزرها و سوییچ به جای آنها (impersonate)
- افزودن صفحهٔ تنظیم Policy نگهداری (Setting) از داخل پنل
- بهبود UI شمسی: پر کردن فیلد `start_time_iso` از پیکر شمسی + پیشنهاد «الآن + ۲ دقیقه»
- احراز هویت viewerها با کد تایید (اختیاری)
- لاگ خطاهای ffmpeg، healthcheck برای پروسه
- استفاده از Alembic migrations بجای create\_all

---

موفق باشیم! این اسکفلد آمادهٔ ران شدن است و گام‌به‌گام می‌توانیم جزئیاتش را کامل‌تر کنیم.

